# Raft论文自我导读
为了方便我随看随查，我决定在阅读raft论文的时候，写一点自己的感受

## Figure3提到的五条raft基本性质
1. Election Safety: 在每一个任期内，最多有一个leader被选出来
2. Leader Append-Only: Leader永远不会覆写或者删除自己的日志；它只添加日志。领导者一旦将日志条目提交，它们就不会被改变。这有助于保持日志的一致性和完整性。领导者只会将新的日志条目附加到现有的日志之后，不会修改或删除已有的条目。
3. Log Matching:  如果两个日志包含相同索引和任期的条目，那么这两个日志在给定索引之前的所有条目都是相同的。
4. Leader Completeness: 如果一个日志条目在一个给定的任期内被提交，那么在所有高于该任期的领导者的日志中都会存在该条目.
5. State Machine Safety: 如果一个服务器已经将某个索引处的日志条目应用到其状态机上，那么不会有其他服务器在相同的索引处应用不同的日志条目。

## 5.1 Raft基本结构

在任何一个时间点，一个raft server只有三种状态的可能： leader, candidate, follower. 正常情况下一个raft集群应该只有一个leader。follower的功能很简单，它们只根据leader和candidate的通信来作出应对。leader负责管理所有来自客户端的命令，并将这些命令分发给follower。candidate则只会在需要选举Leader的时候才会出现。不同状态之间的变化示意可以在论文的figure 4中看到

raft中一个很重要的概念就是任期，term。每一个任期都会发起一次选举，试图从candidate中选出leader。在某些特殊的情况下，会产生split vote的情况，没有leader被选出来。这种情况一旦发生就会进入下一个任期，再进行一次新的选举。每一个raft server都会维护一个叫"currentTerm"的变量，这个变量单调递增。在不同的raft server进行相互通信的时候，它们会交流彼此的currentTerm，一旦遇到了比自己大的term，就将自己的term更新为那个更大的term。 这里需要注意的是，当一个candidate或者leader遇到了比自己大的任期，这个server立刻变回candidate模式。任何一个server遇到了比自己任期小的命令，都不会理会。这一点还是比较好理解的，毕竟不能用前朝的剑斩当今的官。

raft server使用rpc来进行通信。一个candidate想要获得选票成为leader，就要发送RequestVote RPC；一个leader使用AppendEntries RPC来宣示主权，发送命令，直到自己宕机或者被新的任期取代。server定时发送这两种Rpc。目前我们主要关注这两种。

## 5.2 Leader Election
所有server在一开始被启用的时候都是以follower的模式，如果一个follower持续收到来自leader的heartbeat，AppendEntries RPC信息的时候，它就会一直安于现状做一个follower。如果经过一段时间后，这个follower仍然未收到AppendEntries RPC，那么它就会变成一个candidate,试图选自己成为下一个leader。这里我们将这个time out称为 election time out。

这个follower在成为candidate的同时会将自己的currentTerm加1，并且将自己变为candidate状态。这个变化大概可以理解为，新的任期来了，大家都来选我，旧时代已经过去了。candidate同时会选自己，发出RequestVote RPC来募集选票。
candidate会有三种可能： 
1. 赢得选举
2. 其他server成为Leader，这个candidate退回follower
3. 一段时间后没有收到答复，继续选举
   
现在让我们分别来讨论这几种可能性
1. candidate赢得了多数选票，成功当选leader。每一个任期中，每一个服务器只能遵循先到先得的原则来投一次票。一旦一个candidate获得多数选票成为leader，他将定期发送AppendEntries RPC来压制其他服务器。
2. 在candidate等待选票的同时，如果它收到了来自其他服务器的AppendEntries RPC，它会比较彼此的currentTerm。如果这个leader的current Term大于等于candidate的任期，则转变为follower。如果小于，不予理会。
3. 如果超时，candidate仍未获得多数选票，这个candidate则会进行新一轮选举。为了避免无限split vote分票的情况，每次超时时间都设置为150ms到300ms的随机数
   
## 5.3 Log replication

在上一节中我们讲解了leader是怎么被选出来的。Leader负责和client交互，执行client的命令。leader将这条命令存放到日志库中形成一条新日志，接着通过AppendEntries RPC来通知其他raft server来复制这条日志。当多数机器都成功复制这条日志后，leader就会把这条日志放到自身的状态机里并执行，把这条命令的结果返回给client。如果follower宕机或者缓慢运行，又或者网络故障，leader就会一直重复传递这个AppendEntries RPC，直到所有的follower都最终存放了全部的日志。

日志是由leader收到这条命令时的任期和命令本身构成的，日志中的任期用来检查是否存在任何错误。每条日志同时也有一个index用来表示这条日志在所有日志中的位置。

Leader要决定，什么时候真正地把一条日志中的命令真正地放在状态机中执行，被执行了的日志被称为“committed”。Raft系统确保所有commited的日志最终会在所有的机器中被执行。一般来说，一旦一条被leader创建的日志被复制到了大部分机器上的时候，这条日志就可以被commit了。在commit这条日志的同时，所有之前的日志，包括来自其他leader的日志，也一并会被commit掉。Leader一直跟踪他所知道的被committed的最近的index，并且将这个参数附加在AppendEntries RPC中。follower在得知被commited掉的日志参数后，就会在自己的状态机内提交这个命令并执行。

Raft在日志存储中遵循以下规则：如果两个不同的日志中的两个条目有相同的任期和index，那么它们存放的命令是完全一样的，这一点是由leader来保证的；如果两个不同的日志中的两个条目有相同的任期和index，那么它们之前的所有条目都是完全一样的，这一点是由日志复制的规则来保证的。

第一条性质起源于一个事实：在创建日志的时候，leader最多在一个任期内为给定的index创建一个日志，这些日志不改变它们的顺序。第二条性质是被AppendEntries的检查所确认的。当leader发送心跳信号的时候，Index和任期都应该被附加上去。如果follower在它自己的日志里面没有找到对应的有相同index和任期的日志，那么follower拒绝这个日志。（说实话这里没太看懂）一致性检查起到的作用类似于数学归纳法，一开始的空日志状态满足了第一条性质，而一致性检查确保了在添加新日志的时候这条性质仍然被满足。总结下来，每当AppendEntries返回成功，leader就知道这个follower的日志和它自己的日志是一样的。

在正常操作中，leader的日志和follower的日志是一样的，所以AppendEntries永远返回正确。然而，当leader宕机，日志就会变得不一致，旧leader或许并没有完全地将自己的日志完全复制给其他服务器。这些不一致可能会随着leader或者follower的宕机而发生，这些宕机会在figure7中有进一步的阐述。follower可能会缺少Leader的一些日志，也可能有一些leader没有的日志，或者二者均有。缺少日志和多的日志可能会在很多个任期中都出现。

在raft中，leader应对不同日志的办法就是强迫follower复制leader的日志。这意味着Follower中与Leader冲突的日志将会被覆写掉。为了让follower的日志和自己的一样，leader必须找到二者日志中相同部分的最新日志，然后将follower在此日志之后的全部日志都删除，并且把自己剩下的日志发给follower。这个方法的全部过程都是AppendEntries RPC来执行的。

Leader为每一个follower存放一个nextIndex变量，这个变量就是leader为这个follower将要发送的下一个日志的index。当一个leader获得权力的时候，它将nextIndex这个变量初始化为它自己最新的日志index。如果有follower的日志和leader的日志不一样，AppendEntries RPC的一致性检查就会在下一轮调用的时候报错。报错之后，leader就会减小这个follower的nextIndex，重新发送AppendEntries RPC。最终nextIndex会到一个Leader和Follower都同意一致的程度，这时就不会报错，follower就会将这个index之前的日志全部删除，并更新为leader的日志。一旦这个follower对应的AppendEntrie RPC成功，日志就会一直保存成这样，直到任期结束。

如果需要的话，我们可以将raft协议中的被拒绝的AppendEntries RPC的数量减小。举例来说，每当AppendEntries RPC被某个follower拒绝，follower就会把冲突的日志的任期和这个任期对应的第一个index返回给leader。有了这个信息，leader就可以回退地更多，按照任期来回退；实际上来说，这个优化起到的效果并不是很大，因为日志不一致的情况不常发生。

有了这样的机制，当leader获得权力的时候，它不需要采取某些特殊的做法就可以重建日志的一致性。它只需要正常地开始选举，日志就会自动聚拢。leader从不删除或覆写自己的日志。

## 5.4 Safety

之前的章节都聚焦于描述raft如何选出leader，复制日志。然而，这些机制并不能完全确保所有的状态机以相同的顺序执行一样的命令。举例来说，一个follower很可能会在leader确认日志可以被执行的时候掉线，接着它可以被选成新的Leader，覆写新的日志。这样就会导致不同的状态机执行不同的命令。

这一节内容将加入一些针对leader选举的限制，这样就能完整地实现raft协议。这些限制可以确保leader在任何任期都拥有之前所有任期的已经被提交的日志。有了这一条限制，我们接着为提交日志增加更多的规则。最终，我们会证明leader completeness property领导者日志完备性，并显示这个性质会给我们的状态机正确的行为

### 5.4.1 Election Restriction

在任何基于leader选举的共识算法中，leader必须存储所有的已经被提交的日志。raft使用一种机制来确保所有被提交的日志会在每一个被新选到的leader上存在，leader不需要从别的地方转移这些日志过来。这意味着日志只能从leader向follower单向流动，leader从不覆写它自己已经存在的日志。

raft协议使用投票机制来确保，一个candidate必须有全部的已经被提交的日志，它才能被当选为leader。candidate必须和集群中的多数机器沟通，这确保了每一个已经被提交的日志必须在这些机器中的一个存在。如果一个candidate的日志已经和集群中的大部分机器保持了“即时性”，这意味着这个candidate拥有着所有已经被提交的日志（我们将迟点介绍什么是“即时性”）。RequestVote RPC完成了这个机制：rpc中附加了candidate的日志，投票者可以根据这个日志信息和自身的日志信息来决定是否投票。

Raft协议根据任期和日志序列号决定两个日志谁更加“即时”。如果日志最后的一条有着不同的任期，更新任期的日志更加“即时”；如果任期相同，谁的日志更长谁就更新。

### 5.4.2 Committing entries from previous terms

正如我们5.3小节描述的那样，只要某个处在leader当前任期的日志在集群中的多数机器中存下来，leader就可以知道这个日志可以被提交了。如果一个leader在提交这条日志之前宕机，将来的leader将会试图重建这条日志。然而，leader并不能确定之前任期的entry，如果它们被大部分机器所复制，也不能确定是否能被提交。

Raft不会提交之前任期的日志，尽管这个之前任期的日志已经在大多数机器上都存在了。只有哪些属于leader当前任期的日志才会被leader在确认存在于大多数机器之上后才会被提交。一旦当前任期的日志被提交，那么所有之前的任期的日志都会被间接提交，这是由于日志匹配性质。

### 5.4.3 Safety argument

我们用反证法来证明领导者完备性是正确的。假设任期T的leader在他的任期内提交了一个日志，但是这个日志并没有被将来的leader存起来。假设将来的这个leader的任期号是U(U > T)

1. 被提交的这个日志条目必须无法在leaderU的日志中被查找到。（leader从不删除自己的日志）
2. leaderT将这条日志复制到他当时的大部分机器中，leaderU得到了大部分选票。因此，至少有一个服务器同时接受了leaderT的日志，并且给leaderU投了票。这个投票的服务器是我们反证法的关键
3. 这个投票的服务器在给leaderU投票之前必须已经收到了提交这条日志的消息，否则他将会给来自leaderT的AppendEntries RPC返回否。
4. 投票者在给leaderU投票的时候仍然存储着这条日志，因为每一个TU之间的leader都有这条日志。leader从不删除日志，follower只会删除和leader冲突的日志
5. 投票者给leaderU投了一票，所以leaderU必须已经和投票者相同了，这会导致以下悖论中的任意一个
6. 首先，如果投票者和leaderU的最后一个任期都相同，那么leaderU的日志必须至少和投票者相同，因此它的日志包含了投票者的所有日志。这造成一个悖论，投票者有一个已经被提交的但是leaderU并没有的日志
7. 或者来说，leaderU的最后一个任期日志必须大于投票者的最后一个任期，大于T。更早的创建leaderU最后一个日志条目的领导者必须在其日志中包含被提交的条目（根据假设）。然后，根据日志匹配特性，leaderU的日志也必须包含被提交的条目，这是一个矛盾。
8. 反证法完成了。所有大于T的任期的领导者必须包含所有在任期T中提交的条目
9. 日志匹配特性保证了未来的领导者也会包含间接提交的条目