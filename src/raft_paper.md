# Raft论文自我导读
为了方便我随看随查，我决定在阅读raft论文的时候，写一点自己的感受

## 5.1 Raft基本结构

在任何一个时间点，一个raft server只有三种状态的可能： leader, candidate, follower. 正常情况下一个raft集群应该只有一个leader。follower的功能很简单，它们只根据leader和candidate的通信来作出应对。leader负责管理所有来自客户端的命令，并将这些命令分发给follower。candidate则只会在需要选举Leader的时候才会出现。不同状态之间的变化示意可以在论文的figure 4中看到

raft中一个很重要的概念就是任期，term。每一个任期都会发起一次选举，试图从candidate中选出leader。在某些特殊的情况下，会产生split vote的情况，没有leader被选出来。这种情况一旦发生就会进入下一个任期，再进行一次新的选举。每一个raft server都会维护一个叫"currentTerm"的变量，这个变量单调递增。在不同的raft server进行相互通信的时候，它们会交流彼此的currentTerm，一旦遇到了比自己大的term，就将自己的term更新为那个更大的term。 这里需要注意的是，当一个candidate或者leader遇到了比自己大的任期，这个server立刻变回candidate模式。任何一个server遇到了比自己任期小的命令，都不会理会。这一点还是比较好理解的，毕竟不能用前朝的剑斩当今的官。

raft server使用rpc来进行通信。一个candidate想要获得选票成为leader，就要发送RequestVote RPC；一个leader使用AppendEntries RPC来宣示主权，发送命令，直到自己宕机或者被新的任期取代。server定时发送这两种Rpc。目前我们主要关注这两种。

## 5.2 Leader Election
所有server在一开始被启用的时候都是以follower的模式，如果一个follower持续收到来自leader的heartbeat，AppendEntries RPC信息的时候，它就会一直安于现状做一个follower。如果经过一段时间后，这个follower仍然未收到AppendEntries RPC，那么它就会变成一个candidate,试图选自己成为下一个leader。这里我们将这个time out称为 election time out。

这个follower在成为candidate的同时会将自己的currentTerm加1，并且将自己变为candidate状态。这个变化大概可以理解为，新的任期来了，大家都来选我，旧时代已经过去了。candidate同时会选自己，发出RequestVote RPC来募集选票。
candidate会有三种可能： 
1. 赢得选举
2. 其他server成为Leader，这个candidate退回follower
3. 一段时间后没有收到答复，继续选举
   
现在让我们分别来讨论这几种可能性
1. candidate赢得了多数选票，成功当选leader。每一个任期中，每一个服务器只能遵循先到先得的原则来投一次票。一旦一个candidate获得多数选票成为leader，他将定期发送AppendEntries RPC来压制其他服务器。
2. 在candidate等待选票的同时，如果它收到了来自其他服务器的AppendEntries RPC，它会比较彼此的currentTerm。如果这个leader的current Term大于等于candidate的任期，则转变为follower。如果小于，不予理会。
3. 如果超时，candidate仍未获得多数选票，这个candidate则会进行新一轮选举。为了避免无限split vote分票的情况，每次超时时间都设置为150ms到300ms的随机数
   
## 5.3 Log replication

在上一节中我们讲解了leader是怎么被选出来的。Leader负责和client交互，执行client的命令。leader将这条命令存放到日志库中形成一条新日志，接着通过AppendEntries RPC来通知其他raft server来复制这条日志。当多数机器都成功复制这条日志后，leader就会把这条日志放到自身的状态机里并执行，把这条命令的结果返回给client。如果follower宕机或者缓慢运行，又或者网络故障，leader就会一直重复传递这个AppendEntries RPC，直到所有的follower都最终存放了全部的日志。
日志是由leader收到这条命令时的任期和命令本身构成的，日志中的任期用来检查是否存在任何错误。每条日志同时也有一个index用来表示这条日志在所有日志中的位置。
Leader要决定，什么时候真正地把一条日志中的命令真正地放在状态机中执行，被执行了的日志被称为“committed”。Raft系统确保所有commited的日志最终会在所有的机器中被执行。一般来说，一旦一条被leader创建的日志被复制到了大部分机器上的时候，这条日志就可以被commit了。在commit这条日志的同时，所有之前的日志，包括来自其他leader的日志，也一并会被commit掉。Leader一直跟踪他所知道的被committed的最近的index，并且将这个参数附加在AppendEntries RPC中。follower在得知被commited掉的日志参数后，就会在自己的状态机内提交这个命令并执行。
Raft在日志存储中遵循以下规则：如果两个不同的日志有相同的任期和index，那么它们存放相同命令；如果两个不同的日志有相同的任期和index，那么这些日志都是相同的
第一条性质起源于一个事实：在创建日志的时候，leader最多在一个任期内为给定的index创建一个日志，这些日志不改变它们的顺序。第二条性质是被AppendEntries的检查所确认的。当leader发送心跳信号的时候，Index和任期都应该被附加上去。如果follower在它自己的日志里面没有找到对应的有相同index和任期的日志，那么follower拒绝这个日志。（说实话这里没太看懂）一致性检查起到的作用类似于数学归纳法，一开始的空日志状态满足了第一条性质，而一致性检查确保了在添加新日志的时候这条性质仍然被满足。总结下来，每当AppendEntries返回成功，leader就知道这个follower的日志和它自己的日志是一样的。
在正常操作中，leader的日志和follower的日志是一样的，所以AppendEntries永远返回正确。然而，当leader宕机，日志就会变得不一致，旧leader或许并没有完全地将自己的日志完全复制给其他服务器。这些不一致可能会随着leader或者follower的宕机而发生，这些宕机会在figure7中有进一步的阐述。follower可能会缺少Leader的一些日志，也可能有一些leader没有的日志，或者二者均有。缺少日志和多的日志可能会在很多个任期中都出现。
在raft中，leader应对不同日志的办法就是强迫follower复制leader的日志。这意味着Follower中与Leader冲突的日志将会被覆写掉。为了让follower的日志和自己的一样，leader必须找到二者日志中相同部分的最新日志，然后将follower在此日志之后的全部日志都删除，并且把自己剩下的日志发给follower。这个方法的全部过程都是AppendEntries RPC来执行的。
Leader为每一个follower存放一个nextIndex变量，这个变量就是leader为这个follower将要发送的下一个日志的index。当一个leader获得权力的时候，它将nextIndex这个变量初始化为它自己最新的日志index。如果有follower的日志和leader的日志不一样，AppendEntries RPC的一致性检查就会在下一轮调用的时候报错。报错之后，leader就会减小这个follower的nextIndex，重新发送AppendEntries RPC。最终nextIndex会到一个Leader和Follower都同意一致的程度，这时就不会报错，follower就会将这个index之前的日志全部删除，并更新为leader的日志。一旦这个follower对应的AppendEntrie RPC成功，日志就会一直保存成这样，直到任期结束。
如果需要的话，我们可以将raft协议中的被拒绝的AppendEntries RPC的数量减小。举例来说，每当AppendEntries RPC被某个follower拒绝，follower就会把冲突的日志的任期和这个任期对应的第一个index返回给leader。有了这个信息，leader就可以回退地更多，按照任期来回退；实际上来说，这个优化起到的效果并不是很大，因为日志不一致的情况不常发生。
有了这样的机制，当leader获得权力的时候，它不需要采取某些特殊的做法就可以重建日志的一致性。它只需要正常地开始选举，日志就会自动聚拢。leader从不删除或覆写自己的日志。

## 5.4 Safety

